describe("linter.pmd", function()
  local pmd = require("lint.linters.pmd")

  local parser = require("lint.parser").for_sarif(
    pmd.diagnostic_skeleton,
    vim.tbl_extend("force", {}, pmd.sarif_config, {
      fname_to_bufnr = function(fname)
        return fname == "file:///home/kmoschcau/Downloads/foo.java" and 1 or 42
      end,
    })
  )

  describe("when given a SARIF log in JSON format, generated by checkstyle", function()
    it("can parse the log", function()
      local result = parser(
        [[
{
  "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "PMD",
          "version": "7.9.0",
          "informationUri": "https://docs.pmd-code.org/latest/",
          "rules": [
            {
              "id": "NoPackage",
              "shortDescription": {
                "text": "All classes, interfaces, enums and annotations must belong to a named package"
              },
              "fullDescription": {
                "text": "\nDetects when a class, interface, enum or annotation does not have a package definition.\n        "
              },
              "helpUri": "https://docs.pmd-code.org/pmd-doc-7.9.0/pmd_rules_java_codestyle.html#nopackage",
              "help": {
                "text": "\nDetects when a class, interface, enum or annotation does not have a package definition.\n        "
              },
              "properties": {
                "ruleset": "Code Style",
                "priority": 3,
                "tags": [
                  "Code Style"
                ]
              }
            },
            {
              "id": "ClassNamingConventions",
              "shortDescription": {
                "text": "The class name 'foo' doesn't match '[A-Z][a-zA-Z0-9]*'"
              },
              "fullDescription": {
                "text": "\n            Configurable naming conventions for type declarations. This rule reports\n            type declarations which do not match the regex that applies to their\n            specific kind (e.g. enum or interface). Each regex can be configured through\n            properties.\n\n            By default, this rule uses the standard Java naming convention (Pascal case).\n            \n            The rule can detect utility classes and enforce a different naming convention\n            on those. E.g. setting the property `utilityClassPattern` to\n            `[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)` reports any utility class, whose name\n            does not end in \"Util(s)\", \"Helper\" or \"Constants\".\n            \n            For this rule, a utility class is defined as: a concrete class that does not\n            inherit from a super class or implement any interface and only has static fields\n
       or methods.\n\n            This rule detects test classes using the following convention: Test classes are top-level classes, that\n            either inherit from JUnit 3 TestCase or have at least one method annotated with the Test annotations from\n            JUnit4/5 or TestNG.\n        "
              },
              "helpUri": "https://docs.pmd-code.org/pmd-doc-7.9.0/pmd_rules_java_codestyle.html#classnamingconventions",
              "help": {
                "text": "\n            Configurable naming conventions for type declarations. This rule reports\n            type declarations which do not match the regex that applies to their\n            specific kind (e.g. enum or interface). Each regex can be configured through\n            properties.\n\n            By default, this rule uses the standard Java naming convention (Pascal case).\n            \n            The rule can detect utility classes and enforce a different naming convention\n            on those. E.g. setting the property `utilityClassPattern` to\n            `[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)` reports any utility class, whose name\n            does not end in \"Util(s)\", \"Helper\" or \"Constants\".\n            \n            For this rule, a utility class is defined as: a concrete class that does not\n            inherit from a super class or implement any interface and only has static fields\n
       or methods.\n\n            This rule detects test classes using the following convention: Test classes are top-level classes, that\n            either inherit from JUnit 3 TestCase or have at least one method annotated with the Test annotations from\n            JUnit4/5 or TestNG.\n        "
              },
              "properties": {
                "ruleset": "Code Style",
                "priority": 1,
                "tags": [
                  "Code Style"
                ]
              }
            }
          ]
        }
      },
      "results": [
        {
          "ruleId": "NoPackage",
          "ruleIndex": 0,
          "message": {
            "text": "All classes, interfaces, enums and annotations must belong to a named package"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/kmoschcau/Downloads/foo.java"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 1,
                  "endLine": 1,
                  "endColumn": 6
                }
              }
            }
          ]
        },
        {
          "ruleId": "ClassNamingConventions",
          "ruleIndex": 1,
          "message": {
            "text": "The class name 'foo' doesn't match '[A-Z][a-zA-Z0-9]*'"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///home/kmoschcau/Downloads/foo.java"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 1,
                  "endLine": 1,
                  "endColumn": 6
                }
              }
            }
          ]
        }
      ],
      "invocations": [
        {
          "executionSuccessful": true,
          "toolConfigurationNotifications": [],
          "toolExecutionNotifications": []
        }
      ]
    }
  ]
}
        ]],
        1
      )

      assert.are.same(2, #result)

      assert.are.same({
        bufnr = 1,
        lnum = 0,
        end_lnum = 0,
        col = 0,
        end_col = 4,
        severity = vim.diagnostic.severity.WARN,
        message = "All classes, interfaces, enums and annotations must belong to a named package",
        source = "PMD",
        code = "NoPackage",
      }, result[1])

      assert.are.same({
        bufnr = 1,
        lnum = 0,
        end_lnum = 0,
        col = 0,
        end_col = 4,
        severity = vim.diagnostic.severity.ERROR,
        message = "The class name 'foo' doesn't match '[A-Z][a-zA-Z0-9]*'",
        source = "PMD",
        code = "ClassNamingConventions",
      }, result[2])
    end)
  end)
end)
